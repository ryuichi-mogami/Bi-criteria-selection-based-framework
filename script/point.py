""" Generate a set of reference points by translating a set of weight vectors. Thus, the corresponding set of weight vectors should be generated a priori. For details, see the following reference:

    Y. Tian, X. Xiang, X. Zhang, R. Cheng, and Y. Jin, "Sampling Reference Points on the Pareto Fronts of Benchmark Multi-Objective Optimization Problems," in IEEE CEC, 2018, pp. 1â€“6
"""
#!/usr/bin/env python
# -*- coding: utf-8 -*-
import sys
import os
import numpy as np
import copy
import math
import click
import itertools

# from pymoo.util.ref_dirs import get_reference_directions
# from pymoo.util.ref_dirs.energy import RieszEnergyReferenceDirectionFactory

from pyDOE import lhs

# This function is from Platypus: https://github.com/Project-Platypus/Platypus/blob/master/platypus/weights.py
def normal_boundary_weights(nobjs, divisions_outer, divisions_inner=0):
    """Returns weights generated by the normal boundary method.
    
    The weights produced by this method are uniformly distributed on the
    hyperplane intersecting
    
        [(1, 0, ..., 0), (0, 1, ..., 0), ..., (0, 0, ..., 1)].
        
    Parameters
    ----------
    nobjs : int
        The number of objectives.
    divisions_outer : int
        The number of divisions along the outer set of weights.
    divisions_inner : int (optional)
        The number of divisions along the inner set of weights.
    """
    
    def generate_recursive(weights, weight, left, total, index):
        if index == nobjs - 1:
            weight[index] = float(left) / float(total)
            weights.append(copy.copy(weight))
        else:
            for i in range(left+1):
                weight[index] = float(i) / float(total)
                generate_recursive(weights, weight, left-i, total, index+1)
    
    def generate_weights(divisions):
        weights = []
        generate_recursive(weights, [0.0]*nobjs, divisions, divisions, 0)
        return weights
        
    weights = generate_weights(divisions_outer)
    
    if divisions_inner > 0:
        inner_weights = generate_weights(divisions_inner)
        
        for i in range(len(inner_weights)):
            weight = inner_weights[i]
            
            for j in range(len(weight)):
                weight[j] = (1.0 / nobjs + weight[j]) / 2.0
                
            weights.append(weight)
        
    return weights

def w_numbers(n_obj, n_div):
    """Return the number of weight vectors generated by the simplex lattice design based on a given number of divisions.

    :param n_obj: int: The number of objectives
    :param n_div: int: The number of divisions

    :return  The number of resulting weight vectors
    """    
    tmp1 = n_div + n_obj - 1
    tmp2 = n_obj - 1
    return int(math.factorial(tmp1) / (math.factorial(tmp2) * math.factorial(tmp1 - tmp2)))

def n_division_weights(n_obj=2, max_n_div=100):
    """Return (1) the number of divisions and (2) the number of weight vectors generated by the simplex lattice design. Note that this function does not generate actual weight vectors.

    :param n_obj: int: The number of objectives
    :param max_n_div: int: The maximum number of divisions. 

    :return Two ndarrays of the numbers of divisions and the numbers of weight vectors.
    """
    n_divs = np.arange(1, max_n_div+1)
    n_weights = []
    for n_div in n_divs:
        nw = w_numbers(n_obj, n_div)
        n_weights.append(nw)
        print(n_div, nw)
        
    return n_divs, np.array(n_weights)
        
def weight_points(n_obj, n_div):
    """ Generate a set of weight vectors by the simplex lattice design (or the two-layered simplex lattice design).
    """
    weight_point_dir_path = './weight_point_dataset'
    os.makedirs(weight_point_dir_path, exist_ok=True)        

    n_ref_points = w_numbers(n_obj, n_div)        
    w_set = np.array(normal_boundary_weights(nobjs=n_obj, divisions_outer=n_div, divisions_inner=0))
    weight_point_file_path = os.path.join(weight_point_dir_path, 'd{}_n{}.csv'.format(n_obj, n_ref_points))
    np.savetxt(weight_point_file_path, w_set, delimiter=',')

# @click.command()
# @click.option('--n_obj', '-no', required=True, default=2, type=int, help='The number of objectives.')
# @click.option('--n_weight', '-nw', required=True, default=10, type=int, help='The number of weight vectors.')
def pymoo_weight_points(n_obj, n_weight):    
    """ Generate a set of weight vectors by an iterative improvement method that tries to minimize the s-energy value. For details, see the following refrence. The implementation of pymoo is used.

    Julian Blank, Kalyanmoy Deb, Yashesh D. Dhebar, Sunith Bandaru, Haitham Seada: Generating Well-Spaced Points on a Unit Simplex for Evolutionary Many-Objective Optimization. IEEE Trans. Evol. Comput. 25(1): 48-60 (2021)

    :param n_obj: int: The number of objectives
    :param n_weight: int: The number of weight vectors

    """
    weight_point_dir_path = './weight_point_dataset'
    os.makedirs(weight_point_dir_path, exist_ok=True)    
    weight_point_file_path = os.path.join(weight_point_dir_path, 'd{}_n{}.csv'.format(n_obj, n_weight))

    points = get_reference_directions("energy", n_obj, n_weight, seed=1)
    np.savetxt(weight_point_file_path, points, delimiter=',')

        
def create_ref_points_zdt():
    n_obj = 2        
    n_ref_points = 100
    ref_point_dir_path = './ref_point_dataset'
    os.makedirs(ref_point_dir_path, exist_ok=True)    

    for problem in ['zdt1', 'zdt2']:
        ref_point_file_path = os.path.join(ref_point_dir_path, '{}_d{}_n{}.csv'.format(problem, n_obj, n_ref_points))
        fh = open(ref_point_file_path, 'w')

        eq_nums = np.linspace(0, 1, n_ref_points)

        for f1 in eq_nums:            
            if problem == 'zdt1':                
                res = '{},{}\n'.format(f1, 1-np.sqrt(f1))
            elif problem == 'zdt2':                
                res = '{},{}\n'.format(f1, 1-f1**2)
            fh.write(res) 
        fh.close()    
    

def ref_points_DTLZ14(n_obj, problem, n_ref_points):    
    ref_point_dir_path = './ref_point_dataset'
    os.makedirs(ref_point_dir_path, exist_ok=True)    
    #ref_point_file_path = os.path.join(ref_point_dir_path, '{}_d{}_n{}.csv'.format(problem, n_obj, n_ref_points))
    ref_point_file_path = os.path.join(ref_point_dir_path, '{}_d{}_n{}.csv'.format(problem, n_obj, n_ref_points))

    weight_point_file_path = './weight_point_dataset/d{}_n{}.csv'.format(n_obj, n_ref_points)    
    weight_point_set = np.loadtxt(weight_point_file_path, delimiter=',')
    fh = open(ref_point_file_path, 'w')
    
    for w_point in weight_point_set:
        if problem == 'DTLZ1':
            ref_point = 0.5 * w_point
        elif problem == 'SDTLZ1':
            ref_point = 0.5 * w_point
            arr = np.array([10**x for x in range(n_obj)])
            ref_point = ref_point * arr            
        elif problem == 'IDTLZ1':
            ref_point = 0.5 * (1 - w_point)
        elif problem in ['DTLZ2', 'DTLZ3', 'DTLZ4']:        
            trans_value = np.sqrt(np.sum(np.square(w_point)))
            ref_point = w_point / trans_value
        elif problem in ['SDTLZ2', 'SDTLZ3', 'SDTLZ4']:        
            trans_value = np.sqrt(np.sum(np.square(w_point)))
            ref_point = w_point / trans_value
            arr = np.array([10**x for x in range(n_obj)])
            ref_point = ref_point * arr                        
        elif problem in ['IDTLZ2', 'IDTLZ3', 'IDTLZ4']:
            trans_value = np.sqrt(np.sum(np.square(w_point)))            
            ref_point = 1 - (w_point / trans_value)
        elif problem == 'convDTLZ2':        
            trans_value1 = (np.sum(np.sqrt(w_point[:-1])))**2
            trans_value2 = (trans_value1 + 2 * w_point[-1] + np.sqrt(trans_value1**2 + 4 * trans_value1 * w_point[-1])) / 2.0
            ref_point = w_point / trans_value2
        elif problem == 'IconvDTLZ2':        
            trans_value1 = (np.sum(np.sqrt(w_point[:-1])))**2
            trans_value2 = (trans_value1 + 2 * w_point[-1] + np.sqrt(trans_value1**2 + 4 * trans_value1 * w_point[-1])) / 2.0
            ref_point = 1 - (w_point / trans_value2)
        elif problem == 'WFG4':
            trans_value = np.sqrt(np.sum(np.square(w_point)))
            ref_point = w_point / trans_value
            arr = np.array([2**(i+1) for i in range(n_obj)])
            ref_point = ref_point * arr            
            
        str_ref_point = [str(x) for x in ref_point]
        res = ','.join(str_ref_point) + '\n'
        fh.write(res) 
    fh.close()    
    
def ref_points_DTLZ7(n_obj, n_ref_points):
    problem = 'DTLZ7'
       
    if n_obj == 2:
        #grid_size = 300 # for d=2, ref=100
        #grid_size = 3025 # for d=2, ref=100
        grid_size = 151388 # for d=2, ref=60000
        ref_points_dtlz7_2d(n_obj, grid_size, ref_point_file_path=None)
    else:
        # The grid size is 1521 for d=3, 2401
        #grid_size_dict = {3:39,5:7}
        
        #        grid_size = 7 # for d=2, ref=100
        ref_points_dtlz7(n_obj, grid_size=n_ref_points, ref_point_file_path=None)
        #n_ref_points
        
def ref_points_dtlz7_2d(n_obj, grid_size=100, ref_point_file_path='tmp.csv'):
    """
    The method presented in the Tian's CEC paper works for more than 2 objectives but does not work for 2 objectives. For this reason, this function is required specifically for the 2-objective DTLZ7.
    As far as I remember, I implemented this function based on the following website. However, the following website has broken links. 

    https://sop.tik.ee.ethz.ch/download/supplementary/testproblems/dtlz7/index.php#ParetoFront
    """
    problem = 'DTLZ7'
    x = np.linspace(0, 2.116426807, grid_size)

    x1_ranges = [
        [0, 0.2514118360],
        [0.6316265307, 0.8594008566],
        [1.3596178367, 1.5148392681],
        [2.0518383519, 2.116426807]        
    ]

    obj_point_set = []    
    for x1 in x:
        for r in x1_ranges:
            if r[0] <= x1 <= r[1]:
                x2 = 4 - (x1 * (1 + np.sin(3 * np.pi * x1)))
                obj_point_set.append(np.array([x1, x2]))            
                break
                
    n_ref_points = len(obj_point_set)
    obj_point_set = np.array(obj_point_set)

    # # Normalize all the points
    # ideal_point = obj_point_set.min(axis=0)
    # nadir_point = obj_point_set.max(axis=0)
    # obj_point_set = (obj_point_set - ideal_point) / (nadir_point - ideal_point)
           
    if ref_point_file_path == None:
        ref_point_dir_path = './ref_point_dataset'
        os.makedirs(ref_point_dir_path, exist_ok=True)    
        ref_point_file_path = os.path.join(ref_point_dir_path, '{}_d{}_n{}.csv'.format(problem, n_obj, n_ref_points))
        # ref_point_file_path = os.path.join(ref_point_dir_path, '{}_d{}.csv'.format(problem, n_obj))
    np.savetxt(ref_point_file_path, obj_point_set, delimiter=',')                

def ref_points_dtlz7(n_obj=3, grid_size=100, ref_point_file_path=None):
    problem = 'DTLZ7'
    interval = [0, 0.251412, 0.631627, 0.859401]
    median = (interval[1] - interval[0]) / (interval[3] - interval[2] + interval[1] - interval[0])

    # # Grid search
    # x = np.linspace(0, 1, grid_size)
    # l = list(itertools.product(x, repeat=n_obj-1))            
    # grid_point_set = np.array(l)    
    # grid_point_set = np.where(grid_point_set <= median, grid_point_set * (interval[1] - interval[0]) / median + interval[0], (grid_point_set  - median) * (interval[3] - interval[2]) / (1 - median) + interval[2])

    # LHS
    grid_point_set = lhs(n_obj-1, grid_size - 2**(n_obj-1), criterion='center')
    l = []
    for v in list(itertools.product([0, 1],repeat=n_obj-1)):
        l.append(np.asarray(v))
    extreme_point_set = np.array(l)

    grid_point_set = np.concatenate([extreme_point_set, grid_point_set])
    grid_point_set = np.where(grid_point_set <= median, grid_point_set * (interval[1] - interval[0]) / median + interval[0], (grid_point_set  - median) * (interval[3] - interval[2]) / (1 - median) + interval[2])
    
    # print(grid_point_set)
    # exit()
    
    obj_point_set = []    
    for point in grid_point_set:
        mth_p = 0
        for p in point:
            mth_p += (p/2) * (1.0 + np.sin(3 * np.pi * p))        
        mth_p = 2 * (n_obj - mth_p)
        obj_point_set.append(np.append(point, mth_p))

    n_ref_points = len(obj_point_set)
    print(n_ref_points)
    
    if ref_point_file_path == None:
        ref_point_dir_path = './ref_point_dataset'
        os.makedirs(ref_point_dir_path, exist_ok=True)    
        ref_point_file_path = os.path.join(ref_point_dir_path, '{}_d{}_n{}.csv'.format(problem, n_obj, n_ref_points))
        # ref_point_file_path = os.path.join(ref_point_dir_path, '{}_d{}.csv'.format(problem, n_obj))
        
    np.savetxt(ref_point_file_path, np.array(obj_point_set), delimiter=',')
                
    # ndf, _, _, _ = pg.fast_non_dominated_sorting(points=np.array(obj_point_set))    

    # n_ref_points = len(ndf[0])
    # print(n_ref_points, len(grid_point_set))
    
    # #tpb_log_data_file_path = os.path.join(tpb_log_data_dir_path, 'used_budget_{}_f{}_DIM{}_i{}.csv'.format(bbob_suite, fun_id, problem.dimension, instance_id))
    # with open('tmp.csv', 'w') as fh:
    #     for i in ndf[0]: 
    #         data_str = ''
    #         data_str += ','.join([str(p) for p in obj_point_set[i]])
    #         fh.write('{}\n'.format(data_str))

def ref_points_DTLZ56(n_obj, problem, n_ref_points):
    ref_point_dir_path = './ref_point_dataset'
    os.makedirs(ref_point_dir_path, exist_ok=True)    
    ref_point_file_path = os.path.join(ref_point_dir_path, '{}_d{}_n{}.csv'.format(problem, n_obj, n_ref_points))
    fh = open(ref_point_file_path, 'w')
    
    arr = np.linspace(0, 1, n_ref_points)
    for x in arr:
        ref_point = [0] * n_obj
        for i in range(n_obj - 1):        
            ref_point[i] = ((1 / np.sqrt(2))**(n_obj - np.max([i+1, 2]))) * np.cos(0.5 * np.pi * x)
        ref_point[n_obj - 1] = np.sin(0.5 * np.pi * x)

        str_ref_point = [str(y) for y in ref_point]
        res = ','.join(str_ref_point) + '\n'
        fh.write(res)
    fh.close()
    
if __name__ == '__main__':
    #n_division_weights(n_obj=3, max_n_div=1000)
    #n_division_weights(n_obj=4, max_n_div=350) # 2000000
    #n_division_weights(n_obj=5, max_n_div=100)
    #n_division_weights(n_obj=6, max_n_div=60)
    #201376
    
    # # Generate points on the unit simplex for two-objective problems.
    #weight_points(n_obj=2, n_div=999)
    #weight_points(n_obj=10, n_div=13)

    # weight_points(n_obj=2, n_div=60000-1)
    # weight_points(n_obj=3, n_div=423) # 90100
    # weight_points(n_obj=4, n_div=88)
    #weight_points(n_obj=4, n_div=227) # 2001460
    # weight_points(n_obj=5, n_div=42)
    #weight_points(n_obj=5, n_div=86)
    # weight_points(n_obj=6, n_div=27)
    #weight_points(n_obj=6, n_div=49)
    
   # Generate points on the unit simplex for more than two-objective problems. This function requires high computation cost.
    # #    n_weight = 100
    # for n_obj in [3, 5, 8, 10]:
    #     n_weight = n_weight_dir[n_obj]
    #     pymoo_weight_points(n_obj, n_weight)

    # # for m<=4, 30000 * m, for m=5, 6, 500000 * m
    # #n_weight_dir = {2:60000, 3:90100, 4:121485, 5:163185, 6:201376}
    # n_weight_dir = {2:60000, 3:90100, 4:2001460, 5:2555190, 6:3162510}
        
    # for problem in ['DTLZ1', 'DTLZ2', 'DTLZ3', 'DTLZ4', 'SDTLZ1', 'SDTLZ2', 'SDTLZ3', 'SDTLZ4', 'IDTLZ1', 'IDTLZ2', 'IDTLZ3', 'IDTLZ4']:
    #     #for n_obj in [2, 3, 4, 5, 6]:
    #     for n_obj in [4]:            
    #         n_ref_points = n_weight_dir[n_obj]
    #         ref_points_DTLZ14(n_obj, problem, n_ref_points)

    n_weight_dir = {2:50000, 3:50086, 4:102340, 5:455126, 6:3162510}
    # for problem in ['DTLZ1', 'DTLZ2', 'DTLZ3', 'DTLZ4']:
    for problem in ['WFG4']:
        for n_obj in [2, 3, 4, 5, 6]:            
            n_ref_points = n_weight_dir[n_obj]
            ref_points_DTLZ14(n_obj, problem, n_ref_points)
    
    # for problem in ['DTLZ5', 'DTLZ6']:
    #     for n_obj in [2, 3, 4, 5, 6]:
    #         n_ref_points = n_weight_dir[n_obj]
    #         ref_points_DTLZ56(n_obj, problem, n_ref_points)

    # for n_obj in [2, 3, 4, 5, 6]:
    #     n_ref_points = n_weight_dir[n_obj]
    #     ref_points_DTLZ7(n_obj, n_ref_points)
    # #for n_obj in [2, 3, 5, 8, 10]:
    # for n_obj in [4]:
    #     n_ref_points = n_weight_dir[n_obj]
    #     ref_points_DTLZ7(n_obj, n_ref_points)


    # n_weight_dir = {2:60000, 3:90100, 4:121485, 5:163185, 6:201376}
    # #for n_obj in [2, 3, 4, 5, 6]:
    # for n_obj in [4, 5, 6]:        
    #     n_ref_points = n_weight_dir[n_obj]
    #     for problem in ['DTLZ5', 'DTLZ6']:
    #         ref_points_DTLZ56(n_obj, problem, n_ref_points)
        
